<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="Stylesheet" type="text/css" href="../CAADocStyleSheets/caav5.css">
<title>mkCheckSource Filters</title>
</head>

<body>

<table width="100%">
  <tr>
    <td valign="top">
      <h1>RADE</h1>
    </td>
    <td valign="top">
      <h2>C++ Source Checker</h2>
    </td>
    <td rowspan="2" align="right" valign="top">
      <h3><a name="Top"></a>mkCheckSource Filters</h3>
      <em>Testing source code in the CAA V5 environment</em></td>
  </tr>
  <tr>
    <td class="tech" colspan="2">Technical Article</td>
  </tr>
</table>
<hr>
<!---------------------------------comment------------------------------------->
<table class="abstract">
  <tr>
    <td>
      <h3>Abstract</h3>
      <p>Some errors reported by CSC may not be valid, for several reasons. Then
      error filtering can be useful.
      <ul>
        <li><a href="#Problematic"><b>Problematic</b></a></li>
        <li><a href="#ErrorConcerned"><b>Supported types of error</b></a></li>
        <li><a href="#FilterMechanism"><b>Filter mechanism</b></a>
          <ul>
            <li><a href="#Filters">Filters</a></li>
            <li><a href="#CertificationKey">Certification key</a></li>
            <li><a href="#Syntax">Syntax</a></li>
            <li><a href="#FilterLocation">Where to set the filter</a></li>
            <ul>
              <li><a href="#Examples">Examples</a></li>
            </ul>
          </ul>
        </li>
        <li><a href="#Process"><b>Step-by-step Process</b></a></li>
        <ul>
          <li><a href="#1stStep">1st step: validation</a></li>
          <li><a href="#2ndStep">2nd step: generation of the certification key</a>
            <ul>
              <li><a href="#CSCCreateCertificationKey">Synopsis of
                CSCCreateCertificationKey command</a></li>
              <li><a href="#CSCChangeCertificationKey">Synopsis of
                CSCChangeCertificationKey command</a></li>
            </ul>
          </li>
          <li><a href="#3rdStep">3rd step: insertion of filtering tags in source
            file</a></li>
          <li><a href="#4thStep">4th step: verification of filtering correctness</a></li>
        </ul>
        <li><a href="#Options"><b>CSC filtering options</b></a>
          <ul>
            <li><a href="#ignoreFiltering">-ignoreFiltering</a></li>
            <li><a href="#noCheckFiltering">-noCheckFiltering</a></li>
          </ul>
        </li>
        <li><a href="#InShort"><b>In Short</b></a></li>
        <li><a href="#References"><b>References</b></a></li>
      </ul>
  </tr>
</table>
<hr>
<!---------------------------------comment------------------------------------->
<h3><a name="Problematic"></a>Problematic</h3>
<p>There are several causes which can lead to invalid errors generated by CSC:</p>
<ul>
  <li>Limitation coming from tool technology. Example: templates are not
    supported.</li>
  <li>Bug not yet corrected in tool. Example: chained calls are not yet
    supported.</li>
  <li>No preprocessing is done by CSC, except in some precise cases. For
    example: conditional preprocessing directives are not taken into account,
    then the whole code is analyzed as in sequence, which can cause
    misunderstandings of the source code.</li>
  <li>Some invalid coding patterns may be allowed in very particular cases, when
    the impacts of this coding are under control.&nbsp; Example: PUCE errors
    show uses of deprecated entities. But when some functionalities are not yet
    supported by the new entity, use of old one can be allowed.</li>
</ul>
<p>The presence of invalid errors in CSC report have some negative consequences
:</p>
<ul>
  <li>CSC results are not fully reliable, as invalid errors increase the error
    metrics ;</li>
  <li>Complete convergence is impossible ;</li>
  <li>
    <p>Generation of invalid errors by CSC leads to a certain confusion for the
    developer between the &quot;real&quot; errors, which are mandatory to
    correct, and the invalid ones, which should be ignored.</p>
  </li>
</ul>
<p>Then, using the filter mechanism for invalid errors, after a manual code
review, can help to improve efficiency of CSC tool.</p>
<p align="right">[<a href="#Top">Top</a>]</p>

<!---------------------------------comment------------------------------------->

<h3><a name="ErrorConcerned"></a>Supported types of errors</h3>
<p>UINC (see <a href="#References">[5]</a>) is the only kind of error which does 
not support for the moment the filter mechanism. All the other kinds of error 
supports the filtering mechanism, even if some are supposed to be always valid. 
Then, any error reported by CSC tool, excepted UINC one, can be filtered.</p>
<p align="right">[<a href="#Top">Top</a>]</p>

<!---------------------------------comment------------------------------------->

<h3><a name="FilterMechanism"></a>Filter mechanism</h3>
<p>Filtering CSC errors consists in tagging the source files containing the
errors. It is made up of two parts: the filter tags point out the errors to
filter, and a source-level certification tag activates the filters.</p>
<p>If the key contained in the certification tag (referred from now as &quot;the
certification key&quot;) is valid (i.e. has the expected value), the errors
tagged in the source will not be reported by CSC.</p>
<h4><a name="Filters"></a>Filters</h4>
<p>A filter consists in the tag <code>@CSC-Filter</code> and its parameter
&lt;error-type&gt;, which is the type of CSC error(s) it will filter. The type
must be one of those listed in section <a href="#ErrorConcerned">&quot;Supported
types of error&quot;</a>.</p>
<p><b>Example - Filter tag:<br>
</b>The following tag is a filter for a LCVMNAAR error:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre> @CSC-Filter LCVMNAAR</pre>
    </td>
  </tr>
</table>
<p>&nbsp;The following LCVMNAAR error:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>// Some comments 
if (_attribute) _attribute-&gt;<font color="darkred"><b>Release</b></font>(); // LCVMNAAR error is generated
 .... </pre>
    </td>
  </tr>
</table>
<p>can be filter for example in this way:
<table class="code" width="100%">
  <tr>
    <td>
      <pre>if (_attribute) 
    // Some comments
    // <b>@CSC-Filter LCVMNAAR</b> - filter for the invalid LCVMNAAR error generated below:
    // Another comment
    _attribute-&gt;<font color="darkred"><b>Release</b></font>(); // instruction/declaration which generates an error
 ...</pre>
    </td>
  </tr>
</table>
<p>or in this other way:
<table class="code" width="100%">
  <tr>
    <td>
      <pre> ...
 // Some comments
 /** LCVMNAAR error to filter
&nbsp;&nbsp;&nbsp;&nbsp;<b>@CSC-Filter LCVMNAAR</b> - filter for the invalid LCVMNAAR error generated below:
 */
if (_attribute) _attribute-&gt;<font color="darkred"><b>Release</b></font>(); // instruction/declaration which generates an error
 ...</pre>
    </td>
  </tr>
</table>
<p><b>-- End of Example</b></p>
<p>Actually, to filter an error, a tag of this type must be put on a line <b>before</b>
the line containing the error and <b>after </b>the line of code preceeding the
beginning of the inner declaration or instruction containing the entity which
causes the error (the next section -- &quot;<a href="#FilterLocation">Where to
place the filter&quot;</a> -- specifies for each error type which is the entity
to filter). But it will be easier to apply the following rule, more restrictive
but less confusing:</p>
<p><b>Rule: A filter tag <code><b>@CSC-Filter &lt;error-type&gt; </b></code>will
filter all the errors of &lt;error-type&gt; (if there is) generated by the line
of code following this filter.</b></p>
<p>This means that there must be one filter before each line containing at least
one error of the same type to filter. If there are several errors of the same
type on one line, they will all be filtered by one single filter tag (of the
same type). On the other hand, if there are, on one single code line, several
errors of several types to filter, one&nbsp; filter must be set for each error
type generated on the line.</p>
<p>Be careful: there must be no code in the same line as a filter tag.</p>
<p><b>Exception:</b> Filtering <b>LCDMNI</b> and <b>LCDMMN</b> errors (Pointer
Null Part 1 errors [<a href="#References">1</a>]) obeys particular rules. All
LCDMNI (resp. LCDMMN) errors reported for the same constructor method (resp.
destructor method) will be filtered by a single filter, which must be put just
before the declaration of this constructor (resp. destructor).</p>
<h4><a name="CertificationKey"></a>Certification key</h4>
<p>A certification tag is needed in each source file containing CSC filters, in
order to activate these filters. This certification tag ensures that the errors
have been reviewed and are not valid.</p>
<p>A certification tag consists in the tag <code>@CSC-FilterKey</code> and the
value of the certification key as parameter. The certification key is an
unsigned integer computed from the source file name and from the count of
filters of each type existing in this source. All these parameters are
case-sensitive. It is recommended to insert this tag near the top of the file.</p>
<p><b>Example - Certification tag:<br>
</b>&nbsp;The certification tag for a file named myFilter.cpp, and which
contains one filter for a LCVMNAAR error is:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre> @CSC-FilterKey <b>1925307082</b></pre>
    </td>
  </tr>
</table>
<p><b>-- End of Example</b></p>
<p>Then, a key which is valid for a certain file will not be valid for another
file, even if the filters are the same.</p>
<p>Moving a file, moving the filters in the file, changing the code or making
invalid errors disappear (as long as the corresponding filters remain in the
source) does not invalidate the current key. On the other hand, renaming the
file, adding or deleting filters requires to compute the new key value, the old
one being no more valid for the source file modified in this way.</p>
<p>See <a href="#2ndStep">step 2 in Step-by-step process</a> section to find out
how to generate a certification key.&nbsp;</p>
<h4><a name="Syntax"></a>Syntax</h4>
<p>The syntax of the comments is flexible, within a certain limit: tags can be
included in C or C++ comment blocks ; occurrences of other comments before or
after this block are allowed...<br>
But it is needed that the tag name (<code>@CSC-Filter</code> or <code>@CSC-FilterKey</code>)
is separated from their parameter (key, error name) only by &quot;separator
characters&quot; (space, tabulation, new-line and secondarily <code>'*'</code>
for C++ comments). Furthermore, the name and the value of the tag are
case-sensitive.</p>
<h4><a name="FilterLocation"></a>Where to set the filter?</h4>
<p>Here is presented, for each type of error, the code entity which must be
tagged to filter the error. The corresponding line is usually reported in the
error message.</p>
<ul>
  <li>Null Pointer part 1 checks [<a href="#References">1</a>]
    <ul>
      <li><b>LCLVNI</b>: the declaration of the non-initialized pointer.&nbsp;</li>
      <li><b>LCDMNI</b>/<b>LCDMMN</b>: the constructor/destructor definition. It
        will filtered all LCDMNI (resp. LCDMMN) generated in this constructor
        (resp. destructor).</li>
      <li>Assignment after reset by using delete (<b>LCVMNA</b>, <b>LCLVMN</b>),
        Release method (<b>LCVMNAR</b>, <b>LCLVMNAR</b>) or other specific
        delete methods (<b>LCVMNAC</b>, <b>LCLVMNAAC</b>): the call to this
        method (indicated in the error message).</li>
    </ul>
  </li>
  <li>AddRef checks [<a href="#References">2</a>]
    <ul>
      <li><b>AWRS</b>/<b>AWR2</b>/<b>PNSS</b>: the call to the method (indicated
        in the error message) in which the pointer is AddRef'ed.</li>
    </ul>
  </li>
  <li>Callback check [<a href="#References">3</a>]
    <ul>
      <li><b>BCBA</b>: the call to callback method reported in error.</li>
    </ul>
  </li>
  <li>Exception check [<a href="#References">4</a>]
    <ul>
      <li><b>EXCP</b>: the code which throws the exception pointed out.</li>
    </ul>
  </li>
  <li>C++ checks [<a href="#References">5</a>]
    <ul>
      <li><b>BDON</b>/<b>BDON2</b>: the call to <code>delete</code> operator
        indicated in error message.</li>
      <li><b>SCIS</b>: the <code>if</code> instruction reported as erroneous.</li>
      <li><b>IOS1</b>/<b>IOS2</b>: the invalid call to <code>open</code> method.</li>
      <li><b>BVSS</b>: the invalid call to <code>strcpy </code>function.</li>
    </ul>
  </li>
  <li>Forbidden construction checks [<a href="#References">6</a>]
    <ul>
      <li><b>PCOM</b>/<b>UADC</b>: the forbidden call to method or <code>delete</code>
        operator.</li>
      <li><b>UACS</b>: the use of prohibited identifier.</li>
    </ul>
  </li>
</ul>
<h5><a name="Examples"></a>Examples of filter location, depending from the type
of error to filter.</h5>
Remark: for each example, a valid certification key is naturally needed in the
source file to activate the filters.
<ul>
  <li>Null Pointer part 1 checks [<a href="#References">1</a>]
    <ul>
      <li><b>LCLVNI filters:<br>
        </b>Tag the declaration of the non-initialized pointer.
        <p><b>Example - LCLVNI</b>:&nbsp;<br>
        Pointers to array are badly analyzed for the moment by CSC tool, so it
        can lead to invalid errors. Here such a case:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>//...<b>
</b>int i, size, *pos = NULL, newpos, newsize, (*newref)[2], *((*newid)[2]);
// ...</pre>
            </td>
          </tr>
        </table>
        <p>Thus one can filter the errors generated by the declaration of <code>newref</code>
        and <code>newid</code> pointers, as shown here:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>//...
<b>// @CSC-Filter LCLVNI
</b>int i, size, *pos = NULL, newpos, newsize, (*newref)[2], *((*newid)[2]);
// ...</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
      <li><b>LCDMNI/LCDMMN filters:</b><br>
        As mentioned earlier, a filter set just before the definition of a
        constructor/destructor will filtered all LCDMNI/LCDMMN errors generated
        in this method.
        <p><b>Example - LCDMNI:<br>
        </b>As conditional preprocessing directives are not taken into account,
        CSC tool analyzed the following code :</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>CATSupport::CATSupport (const int width, const int height, const void *display) 
           : /*...*/ _StartTimer(0),
#if defined (_AIX)
             _UseTimer(0)
#elif defined(_WINDOWS_SOURCE)
            _shaderCompileAction(NULL), _shaderDrawAction(NULL), _UseTimer(0)
#else
             _Wp1(NULL), _Wp2(NULL), _UseTimer(0)
#endif
{ //...</pre>
            </td>
          </tr>
        </table>
        as
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>CATSupport::CATSupport (const int width, const int height, const void *display) 
           : /*...*/ _StartTimer(0), _UseTimer(0) _shaderCompileAction(NULL), _shaderDrawAction(NULL),
             _UseTimer(0) _Wp1(NULL), _Wp2(NULL), _UseTimer(0)
</pre>
            </td>
          </tr>
        </table>
        <p>in which commas are missing between _UserTimer and
        _shaderCompileAction initializations, and between those of _UseTimer and
        _Wp1. So the tool does not see _shaderCompileAction and _Wp1
        initializations and generates two LCDMNI error.&nbsp;The filter put as
        follows will prevents the two errors to be reported:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre><b>// @CSC-Filter LCDMNI</b>
CATSupport::CATSupport (const int width, const int height, const void *display) 
       // No change in the rest of method
// ...</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
      <li><b>LCVMNA/LCLVMN/LCVMNAR/LCLVMNAR/LCVMNAC/ LCLVMNAAC filters</b>:<br>
        Tag the line containing the call to the method pointed out.
        <p><b>Example - LCVMNAR:</b><br>
        &nbsp;Here a particular case where a pointer must not be assigned after
        being released:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>if (CharacCollector &amp;&amp; (! CharacCollector-&gt;Release()))
   delete <b><font color="darkred">CharacCollector</font></b>;</pre>
            </td>
          </tr>
        </table>
        <p>And here a way to filter the error:
        <table class="code" width="100%">
          <tr>
            <td>
              <pre><b>/******* @CSC-Filter LCLVMNAR ******/</b>
if (CharacCollector &amp;&amp; (! CharacCollector-&gt;Release()))
   delete CharacCollector;</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
    </ul>
  </li>
  <li>AddRef checks [<a href="#References">2</a>]:
    <ul>
      <li><b>AWRS/AWR2/PNSS filters:</b><br>
        Tag the call to the method (indicated in the error message) in which the
        pointer is AddRef'ed.
        <p><b>Example - PNSS:<br>
        </b>Let's assume that CATISpecObject::AddAttribute returns an AddRef'ed
        pointer. The chained calls are not yet supported by CSC, a PNSS error is
        generated by code below:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>CATISpecObject* pIStartupImage = NULL;
// Next line generates an error.
pIStartupImage-&gt;<b><font color="darkred">AddAttribute</font></b>(&quot;DisplayList&quot;, tk_list(tk_component), sp_IN)-&gt;Release();</pre>
            </td>
          </tr>
        </table>
        <p>A filter can be set temporarily:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>CATISpecObject* pIStartupImage = NULL;
/* CSC bug. Waiting for correction...
 * <b>@CSC-Filter PNSS</b> */
pIStartupImage-&gt;AddAttribute(&quot;DisplayList&quot;, tk_list(tk_component), sp_IN)-&gt;Release();</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
    </ul>
  </li>
  <li>Callback check [<a href="#References">3</a>]:
    <ul>
      <li><b>BCBA filter:</b><br>
        Tag the call to callback method reported in error. BCBA errors are
        supposed to be always valid. Filter mechanism is nevertheless provided.
        <p><b>Example - BCBA:<br>
        </b>Here is a piece of code generating 2 BCBA errors, due to invalid
        calls to AddAnalyseNotification method:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>switch(TypeOfView){
   case TheViewInheritance : <b><font color="darkred">AddAnalyseNotificationCB</font></b>(this, GetMenuIActivateNotification(),
                                     (CATCommandMethod)&amp;CATBSpecPushView::ViewInheritance, NULL);
                             break; 
   case TheViewZoom :		  
                             <b><font color="darkred">AddAnalyseNotificationCB</font></b>(this, GetMenuIActivateNotification(),
		                   (CATCommandMethod)&amp;CATBSpecPushView::ViewZoom, NULL);
                             break;
   default;
}</pre>
            </td>
          </tr>
        </table>
        <p>&nbsp;And here the code in which the errors are filtered:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>switch(TypeOfView){
                             <b>//@CSC-Filter BCBA</b>
   case TheViewInheritance : AddAnalyseNotificationCB(this, GetMenuIActivateNotification(),
                                     (CATCommandMethod)&amp;CATBSpecPushView::ViewInheritance, NULL);
                             break; 
   case TheViewZoom :		  
                             <b>//@CSC-Filter BCBA </b>- Be careful, filter can not be in the same line as &quot;case TheViewZoom&quot;
                             AddAnalyseNotificationCB(this, GetMenuIActivateNotification(),
		                   (CATCommandMethod)&amp;CATBSpecPushView::ViewZoom, NULL);
                             break;
   default;
}</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
    </ul>
  </li>
  <li>Exception check [<a href="#References">4</a>]:
    <ul>
      <li><b>EXCP filter:</b><br>
        Tag the instruction which throws the exception pointed out.
        <p><b>Example - EXCP:<br>
        </b>Let's assume that the global function CATBindInterface_B can throw
        an exception. The following code generates a EXCP error:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>//...
SEQUENCE(octet)     name = ...;
CATIBindParameters* parameters = ...;
CATILinkableObject* pointed = NULL;

pointed = <b><font color="darkred">CATBindInterface_B</font></b>(name, CATILinkableObject::ClassName(), parameters);
//...</pre>
            </td>
          </tr>
        </table>
        <p>And here the corresponding filter:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>//...
SEQUENCE(octet)     name = ...;
CATIBindParameters* parameters = ...;
CATILinkableObject* pointed = NULL;

<b>// @CSC-Filter EXCP </b>- EXCP error to filter, exception case.
pointed = CATBindInterface_B(name, CATILinkableObject::ClassName(), parameters);
//...</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
    </ul>
  </li>
  <li>C++ checks [<a href="#References">5</a>]:
    <ul>
      <li><b>BDON/BDON2 filters:</b><br>
        Tag the call to <code>delete</code> operator indicated in error message.
        These errors are supposed to be valid. Nevertheless, here is the manner
        to filter them.
        <p><b>Example - BDON:<br>
        </b>The following code generates a BDON error:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>TestClass* ptr = new ClassTest[12];
<b><font color="darkred">delete</font></b> ptr;</pre>
            </td>
          </tr>
        </table>
        <p>And here the error is filtered:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>TestClass* ptr = new ClassTest[12];
<b>// @CSC-Filter BDON</b>
delete ptr;</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
      <li><b>SCIS filter:</b><br>
        Tag the <code>if</code> instruction reported as erroneous.
        <p><b>Example - SCIS:<br>
        </b>The following code generated a SCIS error:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>if (_attribute &amp;&amp; _attribute-&gt;use());</pre>
            </td>
          </tr>
        </table>
        <p>In the code below, the error is filtered:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre><b>// ------ @CSC-Filter BVSS ------ //</b>
if (_attribute &amp;&amp; _attribute-&gt;use());</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
      <li><b>IOS1/IOS2 filters:</b><br>
        Tag the invalid call to <code>open</code> method. These errors are
        supposed to be valid. Nevertheless, if, here manner of filtering them.
        <p><b>Example - IOS2:</b><br>
        Here a code generating an IOS2 error:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>ofstream dumpFile ;
// File's opening
dumpFile.<b><font color="darkred">open</font></b>(filePathString.CastToCharPtr(), ios::in);</pre>
            </td>
          </tr>
        </table>
        <p>and here the corresponding code with filter:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>ofstream dumpFile ;
<b>// 	@CSC-Filter IOS2
</b>// File's opening
dumpFile.<b><font color="darkred">open</font></b>(filePathString.CastToCharPtr(), ios::in);</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
      <li><b>BVSS filter:</b><br>
        Tag the invalid call to <code>strcpy </code>function. These errors are
        supposed to be valid. Nevertheless, here is the manner of filtering
        them.
        <p><b>Example - BVSS:<br>
        </b>Here a piece of code where a BVSS error is generated:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>char hello [3];
strcpy(hello, &quot;hello&quot;);</pre>
            </td>
          </tr>
        </table>
        <p>And here the same where error is filtered:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>char hello [3];
// Filter for the following error : <b>@CSC-Filter    BVSS</b>
strcpy(hello, &quot;hello&quot;);</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
    </ul>
  </li>
  <li>Forbidden construction checks [<a href="#References">6</a>]:
    <ul>
      <li><b>PCOM/UADC filters</b>:&nbsp;<br>
        Tag the forbidden call to method or <code>delete</code> operator.
        <p><b>Example - UADC:<br>
        </b>In this example, deleting the CATGraphicPrimitive is authorized, as
        the code comes from the graphic primitive modeler.</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>CAT2DLineGP::~CAT2DLineGP(){
   //...
   if (_nbText){
      !_text; 
      CAT2DGeometricTextGP *gp = NULL;
      while (gp=++_text) <b><font color="darkred">delete gp</font></b>;
   }
   // ...</pre>
            </td>
          </tr>
        </table>
        <p>Here the code with filtering:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>CAT2DLineGP::~CAT2DLineGP(){
   //...
   if (_nbText){
      !_text; 
      CAT2DGeometricTextGP *gp = NULL;
      <b>// @CSC-Filter UADC </b>
      while (gp=++_text) delete gp;
   }
   // ...</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></p>
      </li>
      <li><b>UACS filter:</b><br>
        Tag the use of prohibited identifier.
        <p><b>Example - UACS:</b><br>
        Here is an example where ClassName mechanism is use instead of ClassId
        one.&nbsp;</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre>if (hCurr != NULL_var &amp;&amp; 
      (pFilter = 
	hCurr-&gt;QueryInterface(CATISketch::<font color="darkred"><b>ClassName</b></font>())) != NULL){
   // ...</pre>
            </td>
          </tr>
        </table>
        <p>If the context made it necessary, the filtering would be:</p>
        <table class="code" width="100%">
          <tr>
            <td>
              <pre><b>// @CSC-Filter UACS</b>
if (hCurr != NULL_var &amp;&amp; 
      <b>// The filter could have also been inserted here</b>
      (pFilter = 
         <b>// or here</b><b>
</b>         hCurr-&gt;QueryInterface(CATISketch::ClassName())) != NULL){
   // ...</pre>
            </td>
          </tr>
        </table>
        <p><b>-- End of Example</b></li>
    </ul>
  </li>
</ul>
<p align="right">[<a href="#Top">Top</a>]</p>

<!---------------------------------comment------------------------------------->

<h3><a name="Process"></a>Step-by-step process</h3>
<h4><a name="1stStep"></a>1st step: validation</h4>
<p>Check that the error is really an invalid one.</p>
<p>Particularly, one must check that the error is not caused by the inaccuracy
of the settings file used during the CSC run (a macro not expanded, a method
falsely declared as returning an AddRef'ed pointer ...). In this case, the
settings file should be updated (see [<a href="#References">7</a>]).</p>
<h4><a name="2ndStep"></a>2nd step: generation of the certification key</h4>
<p>The certification key is computed from the source file name, and the number
of filters for each error type. Be careful: all these parameters are case
sensitive.</p>
<p>If the source file does not still contain a certification key, use <b>CSCCreateCertificationKey</b>
command.</p>
<h5><a name="CSCCreateCertificationKey"></a>Synopsis of
CSCCreateCertificationKey command</h5>
<pre>CSCCreateCertificationKey [-h] [-s &lt;source&gt;]  (-filter &lt;error &gt; &lt;number&gt;)* [-out &lt;file&gt;] </pre>
<table width="100%" cellspacing="3">
  <tbody>
    <tr>
      <td width="254"><code>-h</code></td>
      <td width="879">displays help.</td>
    </tr>
    <tr>
      <td width="254"><code>-s source</code></td>
      <td width="879">name of source file, including extension.</td>
    </tr>
    <tr>
      <td width="254"><code>-filter error number</code></td>
      <td width="879">for each type of error to filter, the name of the error
        and the number of filters for this error type one wants to insert in the
        file.</td>
    </tr>
    <tr>
      <td width="254"><code>-out file<code></code></code></td>
      <td width="879">to keep a trace of the command result. If <i>file</i> does
        not exist, it will be created. <i>file </i>will contained more or less
        the same output as the one obtained on the standard output.</td>
    </tr>
  </tbody>
</table>
Be careful, all arguments are case-sensitive.
<p><b>Example 1 - CSCCreateCertificationKey:<br>
</b>This command creates a key for myFile.cpp, in which there is one LCVMNAAR
errror to filter:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>&gt; CSCCreateCertificationKey -s myFile.cpp -filter LCVMNAAR 1
Errors of type LCVMNAAR: 1 to filter.
# CKEY-RESULT: certification key for aFile.cpp is:
####### <b>1925307082</b></pre>
    </td>
  </tr>
</table>
<p>The key generated for aFile.cpp is <b>1925307082</b>.</p>
<p><b>-- End of Example</b></p>
<p><b>Example 2 - CSCCreateCertificationKey:<br>
</b>The following command creates a key for a file named aFile.cpp, in which one
wants to insert 1 filter for AWRS errors and 2 filters for LCVMNA errors, with
an output file generated:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>&gt; CSCCreateCertificationKey -s aFile.cpp -filter AWRS 1 -filter LCVMNA 2 -out ../myOutFile.txt
Errors of type AWRS: 1 to filter.
Errors of type LCVMNA: 2 to filter.
# CKEY-RESULT: certification key for aFile.cpp is:
####### <b>1843354957</b></pre>
    </td>
  </tr>
</table>
<p>The key generated for aFile.cpp is <b>1843354957</b>.</p>
<p><b>-- End of Example</b></p>
<p>Otherwise, you can either use <b>CSCCreateCertificationKey</b> command, as
explained above, or the <b>CSCChangeCertificationKey </b>command. This command
enables to specify only the additions and removals for each type of filters and
not the total count.</p>
<h5><a name="CSCChangeCertificationKey"></a>Synopsis of
CSCChangeCertificationKey command</h5>
<pre>CSCChangeCertificationKey [-h] [-s &lt;source_path&gt;]  (-update &lt;error type&gt; &lt;[+,-]n&gt;)* [-out &lt;file&gt;] </pre>
<table width="100%" cellspacing="3">
  <tbody>
    <tr>
      <td width="254"><code>-h</code></td>
      <td width="879">displays help.</td>
    </tr>
    <tr>
      <td width="254"><code>-s source_path</code></td>
      <td width="879">path of a source file.</td>
    </tr>
    <tr>
      <td width="254"><code>-update &lt;error type&gt; &lt;[+,-]n&gt;</code></td>
      <td width="879">for each type of error to filter, the name of the error
        and the number of filters of error type one wants to add or withdraw in
        the file.</td>
    </tr>
    <tr>
      <td width="254"><code>-out file</code></td>
      <td width="879">to keep a trace of command result. If <i>file</i> does not
        exist, it will be created. <i>file</i> will contained more or less the
        same output as the one obtained on the standard output.</td>
    </tr>
  </tbody>
</table>
Be careful, all arguments are case-sensitive.
<p><b>Example 1 - CSCChangeCertificationKey:<br>
</b>One wants to add 1 AWRS filter and remove 1 LCVMNA filter in previous
aFile.cpp</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>&gt; CSCChangeCertificationKey -s ./aFile.cpp -update LCVMNA -1 -update AWRS +1

#### Previous :
# CCKEY-RESULT: Key found in file ./aFile.cpp is &lt;1843354957&gt;

## Error filter of source ./aFile.cpp
   Certification key: 1843354957
   ErrorFilters in source:
   - AWRS :             1 error(s) to filter.
   - LCVMNA :           2 error(s) to filter.
##
# CCKEY-RESULT: Key found in file ./aFile.cpp is valid.

#### Computation of new error filter counts
   Update :
   AWRS :               +1
   LCVMNA :             -1

#### New :
   AWRS :               2 filter(s).
   LCVMNA :             1 filter(s).

# CCKEY-RESULT: new certification key for ./aFile.cpp is:
####### <b>1591679794</b></pre>
    </td>
  </tr>
</table>
<p>The new key generated for aFile.cpp is <b>1591679794</b>.</p>
<p><b>-- End of Example</b></p>
<h4><a name="3rdStep"></a>3rd step: Insertion of filtering tags in source file</h4>
<p>Let take myFile.cpp file, which contains the following invalid error to
filter:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>/**
 * 11/11/2002: Creation
 */
#include &quot;CATBaseUnknown.h&quot;

void myClass::myMethod(){
    if (_attribute) 
        // A comment
        // Another comment
        _attribute-&gt;<font color="darkred"><b>Release</b></font>(); // instruction where error is generated
     ...
}
...</pre>
    </td>
  </tr>
</table>
<p>First, the filtering tag <code>@CSC-Filter LCVMNAAR</code> must be inserted
at the correct location.&nbsp; Section <a href="#FilterLocation">Where to set
the filter</a> specifies that the code entity to tag is the call to Release
method. Then, the file becomes:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>/**
 * 11/11/2002: Creation
 * 12/12/2002: Filtering invalid LCLVMNAAR error in myMethod
 */

#include &quot;CATBaseUnknown.h&quot;

void myClass::myMethod(){
    if (_attribute) 
        // A comment
        // <b>@CSC-Filter LCVMNAAR</b> - filter for the invalid LCVMNAAR error generated below:
        // Another comment
        _attribute-&gt;<font color="darkred"><b>Release</b></font>(); // instruction where error is generated
     ...
}
...</pre>
    </td>
  </tr>
</table>
<p>Then, the certification key must be added. Running the
CSCCreateCertificationKey command (see <a href="#2ndStep">2nd step</a>, Example
1 - CSCCreateCertificationKey) gives the key value 1925307082. The tag
@CSC-FilterKey can be set anywhere, but it is recommended to set it at the
beginning of the source file.</p>
<p>Here the new version of myFile.cpp, where the invalid LCVMNAAR error is no
more reported by CSC:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>/**
 * 11/11/2002: Creation
 * 12/12/2002: Filtering invalid LCLVMNAAR error in myMethod
 */
// <b>@CSC-FilterKey 1925307082</b> - Certification key for CSC tool.

#include &quot;CATBaseUnknown.h&quot;

void myClass::myMethod(){
    if (_attribute) 
        // A comment
        // <b>@CSC-Filter LCVMNAAR</b> - filter for the invalid LCVMNAAR error generated below:
        // Another comment
        _attribute-&gt;Release(); // instruction where error is generated
     ...
}
...</pre>
    </td>
  </tr>
</table>
<p>&nbsp;</p>
<h4><a name="4thStep"></a>4th step: verification of filtering correctness</h4>
<p>Run of command mkCheckSource on the source file must generate the following
message in standard output:<br>
<code>#CSC-INFO: Valid certification key in file &lt;file path&gt;<br>
#CSC-INFO --&gt; Tagged errors will be filtered.</code></p>
<p>and filtered errors should no more be reported by the tool.</p>
<p>If invalid errors appear, referring to the output message must help.
Defective filtering can be due to&nbsp;</p>
<ul>
  <li>Message <code>#CSC-WARNING: Certification key is of unexpected form</code>.<br>
    =&gt; Key of unexpected form. It should be numeric. #CSC-FilterKey tag and
    key value must be separated only by (at least one) &quot;separator
    characters&quot; (see section <a href="#Syntax">Syntax</a>).</li>
  <li>Message <code>#CSC-Warning: Certification key is not valid.</code><br>
    =&gt; Invalid key. Its value depends from source file name (extension
    included) and number of filter of each type. Then, check the file name,
    number of filters of each type in it, spelling of <code>@CSC-Filter</code>
    tag and run again the command. Be careful: all these arguments are case
    sensitive. Check the syntax of the filter tags (see section <a href="#Syntax">Syntax</a>).</li>
  <li>Message <code>#CSC-INFO: Valid certification key in file</code>, but
    filtered errors still appear.<br>
    =&gt; Bad position of filter tag, check it (you can refer to section &quot;<a href="#FilterLocation">Where
    to set the filter</a>&quot;)</li>
  <li>No message about filtering<br>
    =&gt; Absence or bad spelling of <code>CSC-FilterKey</code> tag (See section
    <a href="#Syntax">Syntax</a>).</li>
</ul>
<p>Use of option -noCheckFiltering of mkCheckSource command can help in some
cases (see next part).</p>
<p align="right">[<a href="#Top">Top</a>]</p>

<!---------------------------------comment------------------------------------->

<h3><a name="Options"></a>CSC filtering options</h3>
<table width="100%" cellspacing="6">
  <tr>
    <td valign="TOP" width="27%"><a name="ignoreFiltering"><code>-ignoreFiltering</code></a></td>
    <td width="73%" valign="top">all filters are ignored: all errors, even
      filtered ones, are reported.</td>
  </tr>
  <tr>
    <td valign="TOP" width="27%"><a name="noCheckFiltering"><code>-noCheckFiltering</code></a></td>
    <td width="73%" valign="top">all filters are activated, key values are not
      checked.</td>
  </tr>
</table>
<p>Example:</p>
<p>Here the file myFile.cpp:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>// @CSC-FilterKey 11111111 -- Invalid Key
#include &quot;CATBaseUnknown.h&quot;

void myClass::myMethod()
if (_attribute) 
    // A comment
    // <b>@CSC-Filter LCVMNAAR</b> - filter for the invalid LCVMNAAR error generated below:
    // Another comment
    _attribute-&gt;<font color="darkred"><b>Release</b></font>(); // instruction/declaration where error is generated
 ...</pre>
    </td>
  </tr>
</table>
<p>Running CSC with default filtering option will generate the following output:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>&gt; mkCheckSource -s myFile.cpp
# CSC-INFO: 1 source file to process
<b># CSC-WARNING: Certification key in file myFile.cpp is not valid.
# CSC-WARNING:    found key is &lt;11111111&gt;
# CSC-WARNING:  --&gt; All filter tags in the source are disabled.</b>
LCVMNAAR :    Variable [_attribute] not set to NULL (or to a valid data) after Release at line 9
   in file myFile.cpp
# CSC-INFO: Found <b>1</b> Error and Warning</pre>
    </td>
  </tr>
</table>
<p>Running CSC using option -ignoreFiltering will generate the following output:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>&gt; mkCheckSource -s myFile.cpp -ignoreFiltering
<b># CSC-INFO: Error filters are ignored in all source files.</b>
# CSC-INFO: 1 source file to process
LCVMNAAR :    Variable [_attribute] not set to NULL (or to a valid data) after Release at line 9
   in file myFile.cpp
# CSC-INFO: Found <b>1</b> Error and Warning</pre>
    </td>
  </tr>
</table>
<p>Running CSC using option -noCheckFiltering will generate the following
output:</p>
<table class="code" width="100%">
  <tr>
    <td>
      <pre>&gt; mkCheckSource -s myFile.cpp -noCheckFiltering
<b># CSC-INFO: Validity of certification keys is not checked.
# CSC-INFO:  --&gt; Tagged errors will be filtered.</b>
# CSC-INFO: 1 source files to process
# CSC-INFO: Found <b>0</b> Error and Warning</pre>
    </td>
  </tr>
</table>
<p align="right">[<a href="#Top">Top</a>]</p>
<hr>
<!---------------------------------comment------------------------------------->

<h3><a name="InShort"></a>In Short</h3>
<p>For different reasons, invalid errors can be generated by CSC tool. A filter
mechanism is then provided. It consists in inserting in each source file: filter
tags before invalid errors and a certification key to activates the filtering
mechanism.</p>
<p align="right">[<a href="#Top">Top</a>]</p>
<hr>
<!---------------------------------comment------------------------------------->

<h3><a name="References"></a>References</h3>
<table width="100%">
  <tr>
    <td valign="top">[1]</td>
    <td><a href="CAACscCheck_NullPointers1.htm">Null Pointers Part 1 Checks</a></td>
  </tr>
  <tr>
    <td valign="top">[2]</td>
    <td><a href="CAACscCheck_AddRefRelease.htm">AddRef Release Checks</a></td>
  </tr>
  <tr>
    <td valign="top">[3]</td>
    <td><a href="CAACscCheck_Callback.htm">Callbacks Checks</a></td>
  </tr>
  <tr>
    <td valign="top">[4]</td>
    <td><a href="CAACscCheck_Exception.htm">Exception Checks</a></td>
  </tr>
  <tr>
    <td valign="top">[5]</td>
    <td><a href="CAACscCheck_Cpp.htm">C++ Checks</a></td>
  </tr>
  <tr>
    <td valign="top">[6]</td>
    <td><a href="CAACscCheck_ForbiddenConstructions.htm">Forbidden constructions
      Checks</a></td>
  </tr>
  <tr>
    <td valign="top">[7]</td>
    <td><a href="CAACscSettingFile.htm">Setting Files</a></td>
  </tr>
</table>
<hr>
<!---------------------------------------------------------------------------->
<h3><a name="History"></a>History</h3>
<table width="100%">
  <tr>
    <td valign="top">Version: <strong>1</strong> [Dec 2002]</td>
    <td valign="top">Document created</td>
  </tr>
  <tr>
    <td valign="top" align="right" colspan="2">[<a href="#Top">Top</a>]</td>
  </tr>
</table>
<hr>
<!---------------------------------comment------------------------------------->
<p><i>Copyright © 2002, Dassault Systèmes. All rights reserved.</i></p>

</body>

</html>
